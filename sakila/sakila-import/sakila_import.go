package main

import (
	"database/sql"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"

	. "github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"
	_ "github.com/jackc/pgx/v5/stdlib"
)

func main() {
	err := importData()
	if err != nil {
		panic(err)
	}
}

type specialData struct {
	Tablename string
	Fieldname string
	RefID     map[any]string
}

func importData() error {
	db, err := sql.Open("pgx",
		fmt.Sprintf("postgres://postgres:password@%s:%s/%s?sslmode=disable", "localhost", "5479", "sakila"))
	if err != nil {
		return err
	}

	sdLanguage, err := getSpecialData(db, "language", "language_id", "name")
	if err != nil {
		panic(err)
	}

	sdCategory, err := getSpecialData(db, "category", "category_id", "name")
	if err != nil {
		panic(err)
	}

	sdCountry, err := getSpecialData(db, "country", "country_id", "country")
	if err != nil {
		panic(err)
	}

	sdata := []*specialData{sdLanguage, sdCategory, sdCountry}

	f := NewFile("main")
	f.PackageComment("// Code generated by \"sakila-import\"; DO NOT EDIT.")

	f.ImportAlias("github.com/rrgmc/debefix/v2", "debefix")

	f.Func().Id("Data").Params().Params(Op("*").Qual("github.com/rrgmc/debefix/v2", "Data"), Error()).BlockFunc(func(dataGroup *Group) {
		dataGroup.Id("data").Op(":=").Qual("github.com/rrgmc/debefix/v2", "NewData").Call()

		err = importTable(dataGroup, db, "language", nil, sdata)
		if err != nil {
			panic(err)
		}

		err = importTable(dataGroup, db, "country", nil, sdata)
		if err != nil {
			panic(err)
		}

		err = importTable(dataGroup, db, "city", nil, sdata)
		if err != nil {
			panic(err)
		}

		// err = importTable(dataGroup, db, "address", []string{"city"}, sdata)
		// if err != nil {
		// 	panic(err)
		// }
		//
		// err = importTable(dataGroup, db, "actor", nil, sdata)
		// if err != nil {
		// 	panic(err)
		// }
		//
		// err = importTable(dataGroup, db, "category", nil, sdata)
		// if err != nil {
		// 	panic(err)
		// }
		//
		// err = importTable(dataGroup, db, "film", nil, sdata)
		// if err != nil {
		// 	panic(err)
		// }
		//
		// err = importTable(dataGroup, db, "film_category", nil, sdata)
		// if err != nil {
		// 	panic(err)
		// }
		//
		// err = importTable(dataGroup, db, "film_actor", nil, sdata)
		// if err != nil {
		// 	panic(err)
		// }

		// store and staff depends on each other, more complex logic would be needed to export in the correct order

		// err = importTable(dataGroup, db, "customer", []string{"store", "address"}, sdata, filepath.Join(curDir, "..", "fixtures", "base", "customer.dbf.yaml"))
		// if err != nil {
		// 	panic(err)
		// }

		// err = importTable(dataGroup, db, "staff", []string{"address", "store"}, sdata, filepath.Join(curDir, "..", "fixtures", "base", "staff.dbf.yaml"))
		// if err != nil {
		// 	panic(err)
		// }

		// err = importTable(dataGroup, db, "store", []string{"address", "staff"}, sdata, filepath.Join(curDir, "..", "fixtures", "base", "store.dbf.yaml"))
		// if err != nil {
		// 	panic(err)
		// }

		// err = importTable(dataGroup, db, "inventory", []string{"film", "store"}, sdata, filepath.Join(curDir, "..", "fixtures", "base", "inventory.dbf.yaml"))
		// if err != nil {
		// 	panic(err)
		// }

		// err = importTable(dataGroup, db, "rental", []string{"inventory", "customer", "staff"}, sdata, filepath.Join(curDir, "..", "fixtures", "base", "rental.dbf.yaml"))
		// if err != nil {
		// 	panic(err)
		// }
		//
		// err = importTable(dataGroup, db, "payment", []string{"customer", "staff", "rental"}, sdata, filepath.Join(curDir, "..", "fixtures", "base", "payment.dbf.yaml"))
		// if err != nil {
		// 	panic(err)
		// }

		dataGroup.Return(Id("data"), Nil())
	})

	curDir, err := currentSourceDirectory()
	if err != nil {
		panic(err)
	}

	wf, err := os.Create(filepath.Join(filepath.Dir(curDir), "sakila.go"))
	if err != nil {
		panic(err)
	}
	defer wf.Close()

	return f.Render(wf)
}

func getSpecialData(db *sql.DB, tableName string, fieldName string, textFieldName string) (*specialData, error) {
	rows, err := db.Query(fmt.Sprintf(`SELECT * FROM "%s"`, tableName))
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	sdata := &specialData{
		Tablename: tableName,
		Fieldname: fieldName,
		RefID:     map[any]string{},
	}

	for rows.Next() {
		row, err := rowToMap(rows)
		if err != nil {
			return nil, err
		}

		sdata.RefID[row[fieldName]] = strcase.ToSnake(row[textFieldName].(string))
	}

	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return sdata, nil
}

func getTableVar(tableName string) string {
	return fmt.Sprintf("table%s", strings.ToTitle(tableName))
}

func importTable(dataGroup *Group, db *sql.DB, tableName string, deps []string, sdata []*specialData) error {
	data, err := importTableData(db, tableName, sdata)
	if err != nil {
		return err
	}

	data.Tables[tableName].Config.Depends = deps

	for _, table := range data.Tables {
		tableVar := getTableVar(table.Config.TableName)

		dataGroup.Var().Id(tableVar).Op("=").
			Qual("github.com/rrgmc/debefix/v2", "TableName").Call(Lit(table.Config.TableName))

		for _, row := range table.Rows {
			dataGroup.Id("data").Dot("Add").Call(Id(tableVar),
				Qual("github.com/rrgmc/debefix/v2", "MapValues").
					Values(DictFunc(func(dict Dict) {
						for fn, fv := range row {
							switch cp := fv.(type) {
							case CodeProvider:
								dict[Lit(fn)] = cp()
							case nil:
								dict[Lit(fn)] = Nil()
							default:
								dict[Lit(fn)] = Lit(fv)
							}
						}
					})))
		}
	}

	return nil
}

func importTableData(db *sql.DB, tableName string, sdata []*specialData) (*Data, error) {
	rows, err := db.Query(fmt.Sprintf(`SELECT * FROM "%s"`, tableName))
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	return importTableRows(db, rows, tableName, sdata, nil)
}

func importTableRows(db *sql.DB, rows *sql.Rows, tableName string, sdata []*specialData,
	customize func(row Row) error) (*Data, error) {
	var currentSpecialData *specialData
	for _, s := range sdata {
		if s.Tablename == tableName {
			currentSpecialData = s
			break
		}
	}

	table := &Table{
		Config: TableConfig{
			TableName: tableName,
		},
	}

	for rows.Next() {
		row, err := rowToMap(rows)
		if err != nil {
			return nil, err
		}

		var rowConfig *RowConfig

		if currentSpecialData != nil {
			if rowConfig == nil {
				rowConfig = &RowConfig{}
			}
			rowConfig.RefID = currentSpecialData.RefID[row[currentSpecialData.Fieldname]]
		} else {
			for _, s := range sdata {
				if sfd, ok := row[s.Fieldname]; ok {
					row[s.Fieldname] = CodeProvider(func() Code {
						return Qual("github.com/rrgmc/debefix/v2", "ValueRefID").
							Call(Id(getTableVar(s.Tablename)), Lit(s.RefID[sfd]), Lit(s.Fieldname))
					})
				}
			}
		}

		if rowConfig != nil {
			if rowConfig.RefID != "" {
				row["_refid"] = CodeProvider(func() Code {
					return Qual("github.com/rrgmc/debefix/v2", "SetValueRefID").Call(Lit(rowConfig.RefID))
				})
			}
		}

		if customize != nil {
			err = customize(row)
			if err != nil {
				return nil, err
			}
		}

		table.Rows = append(table.Rows, row)
	}

	if rows.Err() != nil {
		return nil, rows.Err()
	}

	return &Data{
		Tables: map[string]*Table{
			tableName: table,
		},
	}, nil
}

type CodeProvider func() Code

func currentSourceDirectory() (string, error) {
	_, filename, _, ok := runtime.Caller(0)
	if !ok {
		return "", errors.New("unable to get the current filename")
	}
	return filepath.Dir(filename), nil
}
